from oldaplib.src.enums.xsd_datatypes import XsdDatatypes

# PropertyClass

Properties represent and important part of data modelling based on RDF: In triple of the form
```
object – predicate – subject
```
the _property_ represents the _predicate_. As such, the term _property_ is a sysnonym for _predicate_. However,
programmers tend to use the term _property_ instead of _predicate_. Programmers also use the term _resource_ for
the object, since it usually represents a digital _resource_ such as the digital representation (e.g. its metadata)
of a person, a book, or the URL of a digital facsimile, image, video etc.

In data modelling, a property is more than just a semantic definition: a property carries a lot of information about
the _subject_. Most of the information contains restrictions that the value of the property must fulfil. These
restrictions can (and are) validated in OLDAP when instance data is entered or changed. In general, these restrictions
encompass

- if the associated subject must be a _literal_ value
  - the data type of the literal
  - minimal, maximal limits
  - etc.
- or if the associated subject must be another object (resource)
  - What type of resource is allowed?

Restriction are passed to the constructor using the restrictionname. They can be accessed and modified as
"normal" Python-attributes of the PropertyClass instance!

If a _property_ is used within the data modeling of a specific _resource_, a _property_ may carry more
information, such as

- the cardinality that is allowed/required
- the order in which the properties should be presented in a GUI
- etc.

The Python classes "PropertyClass" and "HasPropertyData" are used to represent RDF properties. It is important to note
that OLDAP distinguished between to use classes of properties:

- _standalone properties_: These are properties that are defined on their own without a direct connection/dependence
  on a resource. These property-definition may be __re-used__ for different resource classes.
- _associated properties_: These properties are defined within the context of a resource and can be only used within
  this specific resource.

For both types of properties described above, we distinguish further between data and object properties. This
distinction was adopted in OLDAP from OWL which imposed this distinction.

- _owl:DatatypeProperty_: a property that "points" to a literal value, e.g. `a:myres p:width "50cm"`
- _owl:ObjectProperty_: a property that "points" to another resource, e.g. `a:myres p:author p:schiller`.
  This type of property finally creates the directed graph connection resources as nodes. Such a directed graph is also
  called a _knowledge network_.

The correct OWL types are automatically generated by OLDAP based on the property attributes.

Reusing properties for different resources looks like a good idea but should be applied carefully: The property
definition carries the _semantic meaning_. Therefore, when reusing properties, the semantic meaning _must_ be excately
the same in all cases!

## Functional principles of PropertyClass

A `PropertyClass`-instance is a Python based representation of a property that is defined using RDFS, OWL and SHACL in
the triple store. Changes in the triple store or changes in the Python instance are **not** automatically synchronized.
THe PropertyClass implements the typical CRUD operations (_C_reate, _R_read, _U_pdate and _D_elete)

### Creating
A _PropertyClass_ instance is created using the constructor `PropertyClass()` to create a new Python instance that
is **not yet" existing in the triple store.

**Note**: In order to write the data of the new PropertyClass instance, the method `create()` is used. It creates all the
    necessary triples in the RDFS/OWL ontology graph and in the SHACL graph.

Examples:
```python
p = PropertyClass(con=self._connection,
                  project=self._project,
                  property_class_iri=Iri('test:testprop'),
                  subPropertyOf=Iri('test:comment'),
                  datatype=XsdDatatypes.string,
                  name=LangString(["Test property@en", "Testprädikat@de"]),
                  description={"A property for testing...@en", "Property für Tests@de"})
p.create()
```
### Reading

In order to create an PropertyClass instance from the definitions in the triple store, the classmethod `read()`
has to be used. It reads all the triples and constructs a Python instance of the PropertyClass corresponding to the
information stored in the triple store. Reading combines the information from the
`<project-prefix>:shacl` and `<project-prefix>:onto`graphs.

```python
p1 = PropertyClass.read(con=self._connection,
                        project=self._project,
                        property_class_iri='test:comment',
                        ignore_cache=True)
```

### Updating

A _PropertyClass instance_ is modified by changing the attributes which can be access by their name as python attribute.
However these modifications only change the attributes of the Python instance. In order to change the information in
the triple store, the `update()`-method has to be called.

Example:
```python
p = PropertyClass.read(con=self._connection,
                       project=self._project,
                       property_class_iri=Iri('test:testUpdate2'),
                       ignore_cache=True)
p.name[Language.DE] = 'Annotationen'
p.description = {"a long description@en", "eine lange Beschreibung@de"}
p.languageIn.add(Language.ZU)
p.uniqueLang = False
p.inSet = {"gaga", "is was"}
p.update()
```

### Deleting

Deleting means that the data is completely and permanently removed from the triple store. In order to do so, first a 
Python instance has to be created using the `read()` method. Then by applying the `delete()` method, the data is removed.

Example:
```python
p2 = PropertyClass.read(con=self._connection,
                        project=self._project,
                        property_class_iri=Iri('test:testDeleteIt'),
                        ignore_cache=True)
p2.delete()
```

### Constructor
The generic constructor is defined as follows:
```python
    def __init__(self, *,
                 con: IConnection,
                 creator: Iri | str | None = None,  # DO NOT USE
                 created: Xsd_dateTime | datetime | str | None = None,  # Do NOT USE
                 contributor: Iri | None = None,  # DO NOT USE
                 modified: Xsd_dateTime | datetime | str | None = None,  # DO NOT USE
                 project: Project | Iri | Xsd_NCName | str,
                 property_class_iri: Iri | str | None = None,
                 notifier: Callable[[PropClassAttr], None] | None = None,  # DO NOT USE
                 notify_data: PropClassAttr | None = None,  # DO NOT USE
                 **kwargs):
```
The parameters

- `creator`
- `created`
- `contributor`
- `modified`
- `notifier`
- `notifier_data`

are for **internal use only** and should never used when creating a new property.

- `con`: A valid instance of a connection to a supported triple store.
- `**kwargs`: Additional named parameters as described below

The following examples create a _minimal_ `PropertyClass` instance with no restrictions using the constructor method.
The first example creates a `owl:DatatypeProperty` which points to a _literal value_.

```python
p1 = PropertyClass(con=self._connection,
                   project=self._project,
                   property_class_iri='test:testWrite3',
                   datatype=XsdDatatypes.string)
```

The second example create a `owl:ObjectProperty` which points to another resource class.

```python
p1 = PropertyClass(con=self._connection,
                   project=self._project,
                   property_class_iri='test:testWrite3',
                   toClass='test:MyResClass')
```

_**NOTE**: It is important to note that
the instantiation of a `PropertyClass` does **not** create the property in the triple store! This has to be done
explicitely using the `create()` method_.

## Property attributes

A property has the following attributes.

### name
Datatype: [LangString](/python_docstrings/langstring)

The human readable (short) name of the property. This name should be used in GUI's as label of the input field.

Example:
```python
p1 = PropertyClass(con=self._connection,
                   project=self._project,
                   property_class_iri='test:pictureTitle',
                   datatype=XsdDatatypes.string,
                   name={"Bildtitle@de", "Picture title@en"})
```

### description
Datatype: [LangString](/python_docstrings/langstring)

A human readable description of the property. This description may be used in a GUI to explain the purpose of the
property (e.g. using a popup window)

Example:
```python
p1 = PropertyClass(con=self._connection,
                   project=self._project,
                   property_class_iri='test:pictureTitle',
                   datatype=XsdDatatypes.string,
                   name={"Bildtitle@de", "Picture title@en"},
                   description={"Der von der/dem Künstler:in gegebene Titel des Bildes@de",
                                "The title of the picture as given by the artits@en"})

```

### subPropertyOf
Datatype: [Iri](/python_docstrings/xsd/iri)

_subPropertyOf is in the RDFS-namespace, that is [rdfs:subPropertyOf](https://www.w3.org/TR/rdf-schema/#ch_subpropertyof)
and allows to declare that a certain property is a sub-property of another property (which means that it is
more specialized). E.g. a *side-node* may be a specialized _subPropertyOf_  a *comment* property. This declaration is
only defined in RDFS and can be used for queries. E.g. the search for *comment*
will also return *side-note* properties. The Value of the *subPropertyOf* must be a [Iri](/python_docstrings/xsd/iri) that identifies the
super-property.

Example:
```python
p1 = PropertyClass(con=self._connection,
                   project=self._project,
                   property_class_iri='test:sideNote',
                   subPropertyOf='test:comment',
                   datatype=XsdDatatypes.string
)
```

## Property restrictions

### toClass
Datatype: [Iri](/python_docstrings/xsd/iri)  

This restriction is mandatory for properties that connect to another resource. Only instances of the given ResourceClass
(or subclasses thereof) are allowed!  

Example:
```python
p1 = PropertyClass(con=self._connection,
                   project=self._project,
                   property_class_iri='test:testWrite3',
                   toClass='test:MyResClass')
```
This example restricts the value range of this property to instances of MyResClass.

### datatype
Datatype: [XsdDatatype](/python_docstrings/xsd_datatypes#oldaplib.src.enums.xsd_datatypes.XsdDatatypes)

This restriction is mandatory for properties that are used for literal values. It defines the datatype that the literal
value must have. OLDAP allows most Xsd datatypes.  

Example:
```python
p1 = PropertyClass(con=self._connection,
                   project=self._project,
                   property_class_iri='test:testWrite3',
                   datatype=XsdDatatypes.string)
```
This property requires Xsd_string data.

### languageIn
Datetype: [LanguageIn](/python_docstrings/languagein), set[str]

If the datatype of the property is langString, this attribute of the property restricts the languages that are accepted.

Example:
```python
p1 = PropertyClass(con=self._connection,
                   project=self._project,
                   property_class_iri='test:pictureTitle',
                   datatype=XsdDatatypes.langString,
                   languageIn={'de', 'fr', 'en'})
```
This example restricts the language to German, French and English. The language identifier must confirm to the
[ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes) standard. As alternative, OLDAP provides an
Enum-class [Language](/python_docstrings/language) and a helper class [LanguageIn](/python_docstrings/languagein).
Using this helper classes helps to avoid incorrect language identifiers:
```python
p1 = PropertyClass(con=self._connection,
                   project=self._project,
                   property_class_iri='test:pictureTitle',
                   datatype=XsdDatatypes.langString,
                   languageIn=LanguageIn(Language.EN, Language.DE, Language.FR))
```

### uniqueLang
Datatype: [Xsd_boolean](/python_docstrings/xsd/xsd_boolean), bool

Indicates that each language can occure only once.  
_**Note**: At the moment OLDAP allows only one item per language for all language sensitive strings (as if
_uniqueLang_ is always True). This limitation may be removed in a future version of OLDAP.

Example:
```python
p1 = PropertyClass(con=self._connection,
                   project=self._project,
                   property_class_iri='test:pictureTitle',
                   datatype=XsdDatatypes.langString,
                   uniqueLang=True)
```

### inSet
Datatype: [XsdSet](/python_docstrings/xsdset) or set

The value of the property must be selected from the values given by the _inSet_ attribute.

Example:
```python
p3 = PropertyClass(con=self._connection,
                   project=self._project,
                   property_class_iri=Iri('test:testprop3'),
                   datatype=XsdDatatypes.string,
                   inSet=RdfSet(Xsd_string('yes'), Xsd_string('may be'), Xsd_string('no')))
```
or
```python
p1 = PropertyClass(
    con=self._connection,
    project=self._project,
    property_class_iri=Iri('test:iconImage'),
    toClass=Iri('test:Icon'),
    inSet=RdfSet(Iri("http://www.test.org/icon1"), Iri("http://www.test.org/icon2"))
)

p1 = PropertyClass(
    con=self._connection,
    project=self._project,
    property_class_iri=Iri('test:example'),
    toClass=Iri('test:Example'),
    inSet={'test:ExampleWorks', 'test:ExampleWorng'}
)
```

### minLength
Datatype: [Xsd_integer](/python_docstrings/xsd/xsd_integer)

For string values, this property attribute restricts the minimal length (number of code points/characters) of the
string.

Example:
```python
p1 = PropertyClass(
    con=self._connection,
    project=self._project,
    property_class_iri=Iri('test:password'),
    datatype=XsdDatatypes.string,
    minLength=6
)
```
This example ensures that the property `test:password` has a minimal length of 6 characters.

### maxLength
Datatype: [Xsd_integer](/python_docstrings/xsd/xsd_integer)

For string values, this property attribute restricts the minimal length (number of code points/characters) of the
string.

Example:
```python
p1 = PropertyClass(
    con=self._connection,
    project=self._project,
    property_class_iri=Iri('test:streetName'),
    datatype=XsdDatatypes.string,
    maxLength=128
)
```
This example ensures that the property `test:streetName` has a maximal length of 128 characters.

### pattern
Datatype: [Xsd_string] or str

The _pattern_-restriction validates the value using regex and the given pattern.

Example:
```python
p3 = PropertyClass(
    con=self._connection,
    project=self._project,
    property_class_iri=Iri('test:emailAdress'),
    datatype=XsdDatatypes.string,
    pattern=r"^[\w\.-]+@[a-zA-Z\d-]+\.[a-zA-Z]{2,}(\.[a-zA-Z]{2,})*$"
)
```
This pattern will validate if the given property corresponts syntactically to a valid email adress.

### minExclusive, minInclusive, maxExclusive, maxInclusive
Datatype: *Must be comparable with the datatype of the property*

This restriction checks if the property value is greater than, greater equal, less than or less equal the value of
the _minExclusive_, _minInclusive_, _maxExclusive_, _maxInclusive_ property attribute.

Example:
```python
pX = PropertyClass(
     con=self._connection,
     project=self._project,
     property_class_iri=Iri('test:childAge'),
     datatype=XsdDatatypes.int,
     minExclusive=8,
     maxInclusive=16
)
```
This example restricts the property `test:childAge` to be greater that 8 and less or equal 16.

### lessThan, lessThanOrEquals
Datatype: [Iri](/python_docstrings/xsd/iri)

This property attribute validates the property value against the value in the given property.

Example:
```python
pX = PropertyClass(
     con=self._connection,
     project=self._project,
     property_class_iri=Iri('test:birthDate'),
     datatype=XsdDatatypes.date,
     lessThan=Iri('test:deathDate')
)
```
The above example ensures that the birth date is earlier that the death date.

## Methods of the PropertyClass



### Modifying attributes (restrictions) of a PropertyClass instance

The attributes or restrictions can be added/changed/deleted by directly accessing them with their names. For simple
attributes that just hold a value, the modifications are done as follows:
```python
prop.minLength = 16  # add/replace prop.minLength attribute

del prop.minLength
```
Complex attributes that are sets or LanguageString, the complete attribute can be replaced, or only one item can
be added/replaced deleted:
```python
prop.name = {"My Property@en", "Meine Property@de", "Ma propriété@fr"}  # add/replace prop.name completely

prop.name[Language.IT] = {"La mia proprietà"}  # modify existing (!) prop.name by adding/replacing the italian name only.

del prop.name[Language.ZU]  # delete only the Zulu language name

del prop.name  # Delete the attribute prop.name completely
```



### read()

### create()

### update()

### delete()
